import time
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
start_time = time.time()  # Início da contagem
import pandas as pd
from scipy.interpolate import RegularGridInterpolator


# Parâmetros
beta = 0.987
sigma = 0.007
rho = 0.95
alpha = 1/3
delta = 0.012
mu = 2 
num_k = 100  # Número de pontos no grid de capital
num_z = 7  # Número de estados para o choque TFP


# 1. Discretização do choque TFP usando o método de Tauchen 
m = 2.5  # Parâmetro de dispersão do gride
bound = (sigma / np.sqrt(1 - rho**2)) * m
z_grid = np.linspace(-bound, bound, num_z)



delta_z = z_grid[1] - z_grid[0]  # Espaçamento do grid
P = np.zeros((num_z, num_z))  # Matriz de transição

for i in range(num_z):
    for j in range(num_z - 1):
        lower = (z_grid[j] - rho * z_grid[i]) / sigma
        upper = (z_grid[j + 1] - rho * z_grid[i]) / sigma
        P[i, j] = norm.cdf(upper) - norm.cdf(lower)
        P[i, -1] = 1 - np.sum(P[i, :-1])

df_P = pd.DataFrame(P, index=[f"z_{i}" for i in range(num_z)], columns=[f"z_{i}" for i in range(num_z)])
print("Matriz de Transição Tauchen:")
print(df_P)

# 2. Discretização do capital
k_ss = 48.19
k_grid = np.linspace(0.75 * k_ss, 1.25 * k_ss, num_k)
delta_k = k_grid[1] - k_grid[0]


# 3. Inicialização da função valor
V = np.zeros((num_k, num_z))
V_new = np.zeros_like(V)
policy_c2 = np.zeros((num_k, num_z))
policy_k2 = np.zeros((num_k, num_z))
z_grid = np.exp(z_grid)  # Convertendo para nível de TFP


def utility(c, mu=mu):
    return (c**(1 - mu) - 1) / (1 - mu) if c > 0 else -1e10

# 4. Iteração da Função Valor
tol = 10 ** -6
diff = 1
i = 0
best_idx_matrix = np.zeros((num_k, num_z), dtype=int)

while diff > tol:
    print(f"Número da Iteração {i}: A diferença é {diff}")  # Imprime a iteração atual

    for i_z in range(num_z):
        for i_k in range(num_k):
            k = k_grid[i_k]
            z= z_grid[i_z]
            c_vals = z * k**alpha + (1 - delta) * k - k_grid  # Consumo possível
            
            # Impor restrição de consumo positivo
            valid_idx = c_vals > 0
            
            if np.any(valid_idx):
                util_vals = np.full_like(c_vals, -1e10)  # Penalizar consumo não permitido
                util_vals[valid_idx] = (c_vals[valid_idx]**(1 - mu) - 1) / (1 - mu)  # Aplicar função CRRA
                
                EV = P[i_z, :] @ V.T  # Valor esperado
                total_val = util_vals + beta * EV

                # Ativar np.argmax apenas a cada 10 iterações
                if i % 10 == 0:
                    best_idx = np.argmax(total_val)
                    best_idx_matrix[i_k, i_z] = best_idx  # Salvar melhor índice
                else:
                    best_idx = best_idx_matrix[i_k, i_z]  # Reutilizar o índice salvo

                V_new[i_k, i_z] = total_val[best_idx]  # Atualiza a função valor
                policy_k2[i_k, i_z] = k_grid[best_idx]  # Atualiza a função política do capital
                policy_c2[i_k, i_z] = c_vals[best_idx]  # Atualiza a função política do consumo
            else:
                V_new[i_k, i_z] = -1e10  # Penalizar estados impossíveis
                policy_c2[i_k, i_z] = -1e10  # Penalizar consumo impossível
    
    diff = np.max(np.abs(V - V_new))
    V[:] = V_new  # Atualiza função valor
    i += 1

print(f"Convergência alcançada após {i} iterações. A diferença final é {diff}")

# 4. Interpolação da Função Valor para Dimensão 500x7
num_k_new = 500
k_grid_new = np.linspace(k_grid.min(), k_grid.max(), num_k_new)

# Criando a função de interpolação
interp_func = RegularGridInterpolator((k_grid, np.arange(num_z)), V, method='linear')

# Criando a nova matriz interpolada
V_interp = np.zeros((num_k_new, num_z))
for i_z in range(num_z):
    points = np.array([[k, i_z] for k in k_grid_new])  # Criando pontos para interpolação
    V_interp[:, i_z] = interp_func(points)  # Aplicando interpolação

# Exibir as dimensões da nova matriz
print("Dimensão original de V:", V.shape)
print("Dimensão interpolada de V:", V_interp.shape)
print(np.array_str(V_interp, precision=3, suppress_small=True))  # Mostra com 3 casas decimais

# 5. Inicialização da função valor para grid 500 pontos

num_k=500
k_grid = np.linspace(0.75 * k_ss, 1.25 * k_ss, num_k)
V = V_interp
V_new = np.zeros_like(V)
policy_c1 = np.zeros((num_k, num_z))
policy_k1 = np.zeros((num_k, num_z))



def utility(c, mu=mu):
    return (c**(1 - mu) - 1) / (1 - mu) if c > 0 else -1e10

# Iteração da Função Valor
tol = 10 ** -6
diff = 1
i = 0
best_idx_matrix = np.zeros((num_k, num_z), dtype=int)
max_iter = 1500
while diff > tol and i < max_iter:
    print(f"Número da Iteração {i}: A diferença é {diff}")  # Imprime a iteração atual

    for i_z in range(num_z):
        for i_k in range(num_k):
            k = k_grid[i_k]
            z = z_grid[i_z]
            c_vals = z * k**alpha + (1 - delta) * k - k_grid  # Consumo possível
            
            # Impor restrição de consumo positivo
            valid_idx = c_vals > 0
            
            if np.any(valid_idx):
                util_vals = np.full_like(c_vals, -1e10)  # Penalizar consumo não permitido
                util_vals[valid_idx] = (c_vals[valid_idx]**(1 - mu) - 1) / (1 - mu)  # Aplicar função CRRA
                
                EV = P[i_z, :] @ V.T  # Valor esperado
                total_val = util_vals + beta * EV

                # Ativar np.argmax apenas a cada 10 iterações
                if i % 10 == 0:
                    best_idx = np.argmax(total_val)
                    best_idx_matrix[i_k, i_z] = best_idx  # Salvar melhor índice
                else:
                    best_idx = best_idx_matrix[i_k, i_z]  # Reutilizar o índice salvo

                V_new[i_k, i_z] = total_val[best_idx]  # Atualiza a função valor
                policy_k1[i_k, i_z] = k_grid[best_idx]  # Atualiza a função política do capital
                policy_c1[i_k, i_z] = c_vals[best_idx]  # Atualiza a função política do consumo
            else:
                V_new[i_k, i_z] = -1e10  # Penalizar estados impossíveis
                policy_c1[i_k, i_z] = -1e10  # Penalizar consumo impossível
    
    diff = np.max(np.abs(V - V_new))
    V[:] = V_new  # Atualiza função valor
    i += 1

print(f"Convergência alcançada após {i} iterações. A diferença final é {diff}")

# 6. Plot dos resultados
plt.figure(figsize=(10, 5))
for i in range(7):  
    plt.plot(k_grid, policy_k1[:, i], label=f"z_{i}")  
plt.plot(k_grid, k_grid, '--', label="45 graus", color="black")
plt.xlabel("Capital k")
plt.ylabel("Política de k'")
plt.title("Função Política para Diferentes Estados z")
plt.legend()
plt.show()

plt.figure(figsize=(10, 6))
for i in range(num_z):
    plt.plot(k_grid, policy_c1[:, i], label=f"z_{i}")  
plt.xlabel("Capital k")
plt.ylabel("Consumo c")
plt.title("Função Política do Consumo para Diferentes Estados z")
plt.legend()
plt.show()

plt.figure(figsize=(10, 5))
for i in range(7):  
    plt.plot(k_grid, V[:, i], label=f"z_{i}")  
plt.xlabel("Capital k")
plt.ylabel("Valor V(k, z)")
plt.title("Função Valor para Diferentes Estados z")
plt.legend()
plt.show()


from numpy.polynomial.chebyshev import chebfit, chebval

# Parâmetros
num_k = 500  # Número de pontos no grid de capital
degree = 5  # Ordem do polinômio de Chebyshev
num_z = 7  # Número de estados de Z

# Grid de capital
k_min, k_max = 0.75 * 48.19, 1.25 * 48.19
k_grid = np.linspace(k_min, k_max, num_k)

# Nós de Chebyshev normalizados no intervalo [-1, 1]
cheb_nodes = np.cos((2 * np.arange(1, num_k + 1) - 1) / (2 * num_k) * np.pi)

# Transformação dos nós para o intervalo de capital [k_min, k_max]
k_cheb = 0.5 * (k_max - k_min) * (cheb_nodes + 1) + k_min

# Aproximação de Chebyshev para todos os estados de Z
policy_c1_chebyshev = np.zeros((num_k, num_z))
coeffs_list = []

plt.figure(figsize=(10, 6))

for i in range(num_z):
    # Pegando os valores da função política nos nós de Chebyshev
    policy_c1_values = np.interp(k_cheb, k_grid, policy_c1[:, i])  

    # Ajuste do polinômio de Chebyshev
    coeffs = chebfit(cheb_nodes, policy_c1_values, degree)
    coeffs_list.append(coeffs)

    # Avaliação da função política nos pontos do grid
    policy_c1_chebyshev[:, i] = chebval(2 * (k_grid - k_min) / (k_max - k_min) - 1, coeffs)

    # Plotagem da aproximação
    plt.plot(k_grid, policy_c1_chebyshev[:, i], label=f'Chebyshev Approx. (z={i})')

plt.xlabel("Capital k")
plt.ylabel("Consumo c")
plt.title("Aproximação de Chebyshev da Função de Política de Consumo para Todos os Estados z")
plt.legend()
plt.show()

#9 Inicialização do erro de Euler
erro_euler = np.zeros((num_k, num_z))
# Loop para calcular o erro de Euler
for estado_prod in range(num_z):
    for indice_k in range(num_k):
        k_atual = k_grid[indice_k]
        prod_atual = z_grid[estado_prod]
        k_futuro = policy_k1[indice_k, estado_prod]  # Escolha ótima de capital
        
        # Encontrar o índice mais próximo de k_futuro
        idx_k_futuro = np.argmin(np.abs(k_grid - k_futuro))
        
        # Cálculo do fator de desconto estocástico
        fator_de_desconto = prod_atual * alpha * k_futuro**(alpha - 1) + (1 - delta)
        
        # Expectativa da utilidade marginal
        util_marginal_esperada = 0
        for prox_estado in range(num_z):
            k_futuro_futuro = policy_k1[idx_k_futuro, prox_estado]
            
            # Determinar o consumo futuro
            consumo_futuro = z_grid[prox_estado] * k_futuro**alpha + (1 - delta) * k_futuro - k_futuro_futuro
            consumo_futuro = max(consumo_futuro, 1e-8)  # Evita valores negativos
            
            # Cálculo da utilidade marginal
            util_marginal_futuro = consumo_futuro**(-mu)
           
            util_marginal_esperada += P[estado_prod, prox_estado] * util_marginal_futuro
        
        # Consumo atual
        consumo_atual = policy_c1_chebyshev[indice_k, estado_prod]
        util_marginal_atual = consumo_atual**(-mu)

        
        
        # Cálculo do erro de Euler
        erro = abs((util_marginal_atual - beta * fator_de_desconto * util_marginal_esperada) / util_marginal_atual)
        erro_euler[indice_k, estado_prod] = np.log10(erro)

        # Visualização do erro de Euler
plt.figure(figsize=(10, 5))
for i in range(7):  
    plt.plot(k_grid, erro_euler[:, i], label=f"z_{i}")  
plt.xlabel("Capital k")
plt.ylabel("Erro de Euler")
plt.title("Erro de Euler para Diferentes Estados de Produtividade")
plt.legend()
plt.show()

# Grau do polinômio comum
grau_polinomio = 500  

# Normalizar o grid de capital para o intervalo [-1,1]
k_min, k_max = k_grid.min(), k_grid.max()
k_grid_norm = 2 * (k_grid - k_min) / (k_max - k_min) - 1  

# Inicializar matriz para armazenar os coeficientes do polinômio comum
erro_euler_pol_colocacao = np.zeros_like(erro_euler)

plt.figure(figsize=(10, 6))

# Loop para resolver o sistema de colocação para cada estado z
for i in range(num_z):
    # Pegando os valores do erro de Euler nos pontos do grid
    erro_values = erro_euler[:, i]
    
    # Criar matriz de Vandermonde com potências de x (polinômios normais)
    T = np.vander(k_grid_norm, grau_polinomio + 1, increasing=True)
    
    # Resolver o sistema de mínimos quadrados T @ γ ≈ erro_values
    gamma, _, _, _ = np.linalg.lstsq(T, erro_values, rcond=None)
    
    # Avaliação do polinômio nos pontos do grid original
    erro_euler_pol_colocacao[:, i] = np.polyval(gamma[::-1], k_grid_norm)
    
    # Plotando o polinômio ajustado
    plt.plot(k_grid, erro_euler_pol_colocacao[:, i], label=f'Polinômio (z={i})')

# Configuração do gráfico
plt.xlabel("Capital k")
plt.ylabel("Erro de Euler Aproximado - Polinômio de Grau 500") 
plt.title("Aproximação por Polinômio de Grau 500 do Erro de Euler")
plt.legend()
plt.show()

# Parâmetros
degree = 499  # Ordem do polinômio de Chebyshev


# Grid de capital
k_min, k_max = 0.75 * 48.19, 1.25 * 48.19
k_grid = np.linspace(k_min, k_max, num_k)

# Nós de Chebyshev normalizados no intervalo [-1, 1]
cheb_nodes = np.cos((2 * np.arange(1, num_k + 1) - 1) / (2 * num_k) * np.pi)

# Transformação dos nós para o intervalo de capital [k_min, k_max]
k_cheb = 0.5 * (k_max - k_min) * (cheb_nodes + 1) + k_min

# Aproximação de Chebyshev para erro de Euler
erro_euler_chebyshev = np.zeros((num_k, num_z))
coeffs_list = []

plt.figure(figsize=(10, 6))

for i in range(num_z):
    # Pegando os valores do erro de Euler nos nós de Chebyshev
    erro_euler_values = np.interp(k_cheb, k_grid, erro_euler[:, i])  

    # Ajuste do polinômio de Chebyshev
    coeffs = chebfit(cheb_nodes, erro_euler_values, degree)
    coeffs_list.append(coeffs)

    # Avaliação da aproximação nos pontos do grid
    erro_euler_chebyshev[:, i] = chebval(2 * (k_grid - k_min) / (k_max - k_min) - 1, coeffs)

    # Plotagem da aproximação
    plt.plot(k_grid, erro_euler_chebyshev[:, i], label=f'Chebyshev Approx. (z={i})')

plt.xlabel("Capital k")
plt.ylabel("Erro de Euler")
plt.title("Aproximação de Chebyshev do Erro de Euler para Todos os Estados z")
plt.legend()
plt.show()

end_time = time.time()  # Fim da contagem
execution_time = end_time - start_time

print(f"Tempo total de execução: {execution_time:.6f} segundos")
